/**
 * Single File Exporter - 単体ファイル出力機能
 * JSON/LANG形式での個別言語ファイルのエクスポート
 */

export interface SingleFileExportOptions {
  format: 'json' | 'lang'
  locale?: string
  namespace?: string
  includeMetadata?: boolean
  prettify?: boolean
  sortKeys?: boolean
}

export interface ExportEntry {
  key: string
  value: string
  namespace?: string
  category?: string
}

export class SingleFileExporter {
  /**
   * エントリーをJSON形式にエクスポート
   */
  static exportToJSON(
    entries: ExportEntry[],
    options: Partial<SingleFileExportOptions> = {}
  ): string {
    const config = {
      prettify: true,
      sortKeys: true,
      includeMetadata: false,
      ...options
    }

    // キーと値のマップを作成
    const languageData: { [key: string]: string } = {}
    
    entries.forEach(entry => {
      languageData[entry.key] = entry.value
    })

    // キーをソート（オプション）
    const sortedData = config.sortKeys 
      ? this.sortObjectKeys(languageData)
      : languageData

    // メタデータを含める場合
    if (config.includeMetadata) {
      const metadata = {
        _metadata: {
          generator: 'LangPack Studio',
          version: '1.2.1-alpha',
          timestamp: new Date().toISOString(),
          locale: options.locale || 'unknown',
          namespace: options.namespace || 'minecraft',
          totalEntries: entries.length
        },
        ...sortedData
      }
      return config.prettify 
        ? JSON.stringify(metadata, null, 2)
        : JSON.stringify(metadata)
    }

    return config.prettify 
      ? JSON.stringify(sortedData, null, 2)
      : JSON.stringify(sortedData)
  }

  /**
   * エントリーをLANG形式にエクスポート
   */
  static exportToLANG(
    entries: ExportEntry[],
    options: Partial<SingleFileExportOptions> = {}
  ): string {
    const config = {
      sortKeys: true,
      includeMetadata: false,
      ...options
    }

    // エントリーをソート（オプション）
    const sortedEntries = config.sortKeys
      ? [...entries].sort((a, b) => a.key.localeCompare(b.key))
      : entries

    const lines: string[] = []

    // メタデータをコメントとして含める
    if (config.includeMetadata) {
      lines.push('# Generated by LangPack Studio')
      lines.push(`# Date: ${new Date().toISOString()}`)
      lines.push(`# Locale: ${options.locale || 'unknown'}`)
      lines.push(`# Namespace: ${options.namespace || 'minecraft'}`)
      lines.push(`# Total entries: ${entries.length}`)
      lines.push('')
    }

    // カテゴリーごとにグループ化（オプション）
    const categorizedEntries = this.groupByCategory(sortedEntries)
    
    for (const [category, categoryEntries] of categorizedEntries) {
      if (category && category !== 'uncategorized') {
        lines.push(`# ${category}`)
      }
      
      categoryEntries.forEach(entry => {
        // 特殊文字のエスケープ
        const escapedKey = entry.key
        const escapedValue = entry.value
          .replace(/\\/g, '\\\\')  // バックスラッシュをエスケープ
          .replace(/\n/g, '\\n')   // 改行をエスケープ
          .replace(/\r/g, '\\r')   // キャリッジリターンをエスケープ
        
        lines.push(`${escapedKey}=${escapedValue}`)
      })
      
      if (category && category !== 'uncategorized') {
        lines.push('') // カテゴリー間に空行
      }
    }

    return lines.join('\n')
  }

  /**
   * オブジェクトのキーをソート
   */
  private static sortObjectKeys(obj: { [key: string]: string }): { [key: string]: string } {
    const sorted: { [key: string]: string } = {}
    Object.keys(obj)
      .sort()
      .forEach(key => {
        sorted[key] = obj[key]
      })
    return sorted
  }

  /**
   * エントリーをカテゴリーごとにグループ化
   */
  private static groupByCategory(entries: ExportEntry[]): Map<string, ExportEntry[]> {
    const grouped = new Map<string, ExportEntry[]>()
    
    entries.forEach(entry => {
      const category = entry.category || 'uncategorized'
      if (!grouped.has(category)) {
        grouped.set(category, [])
      }
      grouped.get(category)!.push(entry)
    })
    
    return grouped
  }

  /**
   * ファイル名を生成
   */
  static generateFileName(
    format: 'json' | 'lang',
    locale: string = 'en_us',
    namespace: string = 'minecraft',
    isTranslated: boolean = false
  ): string {
    const prefix = namespace === 'minecraft' ? '' : `${namespace}_`
    const suffix = isTranslated ? '_translated' : ''
    return `${prefix}${locale}${suffix}.${format}`
  }

  /**
   * ブラウザでファイルをダウンロード
   */
  static downloadFile(
    content: string,
    fileName: string,
    mimeType: string = 'application/json'
  ): void {
    const blob = new Blob([content], { type: mimeType })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    
    link.href = url
    link.download = fileName
    document.body.appendChild(link)
    link.click()
    
    // クリーンアップ
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
  }

  /**
   * Electronでファイルを保存
   */
  static async saveFileElectron(
    content: string,
    fileName: string
  ): Promise<boolean> {
    // This method is no longer needed for web version
    return false
  }

  /**
   * 翻訳前後の比較用ファイルを生成
   */
  static exportComparison(
    originalEntries: ExportEntry[],
    translatedEntries: ExportEntry[],
    format: 'json' | 'csv' = 'json'
  ): string {
    if (format === 'csv') {
      return this.exportComparisonCSV(originalEntries, translatedEntries)
    }
    
    // JSON形式での比較
    const comparisonData: any[] = []
    
    // 翻訳済みエントリーのマップを作成
    const translatedMap = new Map<string, string>()
    translatedEntries.forEach(entry => {
      translatedMap.set(entry.key, entry.value)
    })
    
    originalEntries.forEach(entry => {
      comparisonData.push({
        key: entry.key,
        original: entry.value,
        translated: translatedMap.get(entry.key) || '',
        category: entry.category || '',
        namespace: entry.namespace || ''
      })
    })
    
    return JSON.stringify(comparisonData, null, 2)
  }

  /**
   * CSV形式で比較データをエクスポート
   */
  private static exportComparisonCSV(
    originalEntries: ExportEntry[],
    translatedEntries: ExportEntry[]
  ): string {
    const csvLines: string[] = []
    
    // ヘッダー
    csvLines.push('Key,Original,Translated,Category,Namespace')
    
    // 翻訳済みエントリーのマップを作成
    const translatedMap = new Map<string, string>()
    translatedEntries.forEach(entry => {
      translatedMap.set(entry.key, entry.value)
    })
    
    // データ行
    originalEntries.forEach(entry => {
      const original = this.escapeCSV(entry.value)
      const translated = this.escapeCSV(translatedMap.get(entry.key) || '')
      const category = this.escapeCSV(entry.category || '')
      const namespace = this.escapeCSV(entry.namespace || '')
      
      csvLines.push(`${entry.key},${original},${translated},${category},${namespace}`)
    })
    
    return csvLines.join('\n')
  }

  /**
   * CSV用に文字列をエスケープ
   */
  private static escapeCSV(value: string): string {
    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
      return `"${value.replace(/"/g, '""')}"`
    }
    return value
  }

  /**
   * 統計情報付きエクスポート
   */
  static exportWithStats(
    entries: ExportEntry[],
    format: 'json' | 'lang',
    options: Partial<SingleFileExportOptions> = {}
  ): {
    content: string
    stats: {
      totalEntries: number
      totalCharacters: number
      uniqueKeys: number
      categories: string[]
      namespaces: string[]
    }
  } {
    const content = format === 'json' 
      ? this.exportToJSON(entries, options)
      : this.exportToLANG(entries, options)
    
    const uniqueKeys = new Set(entries.map(e => e.key))
    const categories = [...new Set(entries.map(e => e.category).filter(Boolean))]
    const namespaces = [...new Set(entries.map(e => e.namespace).filter(Boolean))]
    const totalCharacters = entries.reduce((sum, e) => sum + e.value.length, 0)
    
    return {
      content,
      stats: {
        totalEntries: entries.length,
        totalCharacters,
        uniqueKeys: uniqueKeys.size,
        categories,
        namespaces
      }
    }
  }
}

// エクスポート用のヘルパー関数
export const exportSingleFile = (
  entries: ExportEntry[],
  format: 'json' | 'lang',
  locale: string,
  namespace: string = 'minecraft',
  download: boolean = true
): string => {
  const options: SingleFileExportOptions = {
    format,
    locale,
    namespace,
    prettify: true,
    sortKeys: true,
    includeMetadata: false
  }
  
  const content = format === 'json'
    ? SingleFileExporter.exportToJSON(entries, options)
    : SingleFileExporter.exportToLANG(entries, options)
  
  if (download) {
    const fileName = SingleFileExporter.generateFileName(format, locale, namespace)
    const mimeType = format === 'json' ? 'application/json' : 'text/plain'
    SingleFileExporter.downloadFile(content, fileName, mimeType)
  }
  
  return content
}