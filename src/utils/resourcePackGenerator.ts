import JSZip from 'jszip'
import { LanguageFile } from '../App'
import { ParseResult, LanguageParser } from './languageParser'
import { getRecommendedVersion, getVersionByPackFormat } from './minecraftVersions'

export interface ResourcePackOptions {
  packName: string
  description: string
  packFormat: number
  supportedFormats?: number | number[] | { min_inclusive: number; max_inclusive: number }
  includeTranslations?: { key: string; value: string; locale: string }[]
  packIcon?: File | Blob
}

export interface ResourcePackResult {
  success: boolean
  zipBlob?: Blob
  errors: string[]
  warnings: string[]
  generatedFiles: {
    path: string
    type: 'meta' | 'language' | 'icon'
    namespace?: string
    locale?: string
  }[]
}

export class ResourcePackGenerator {
  private static readonly DEFAULT_PACK_FORMAT = getRecommendedVersion().packFormat
  private static readonly DEFAULT_DESCRIPTION = 'Generated by LangPack Studio'

  static async generateResourcePack(
    files: LanguageFile[],
    options: Partial<ResourcePackOptions> = {}
  ): Promise<ResourcePackResult> {
    const result: ResourcePackResult = {
      success: false,
      errors: [],
      warnings: [],
      generatedFiles: []
    }

    if (files.length === 0) {
      result.errors.push('No files provided for resource pack generation')
      return result
    }

    const config: ResourcePackOptions = {
      packName: options.packName || 'Generated Language Pack',
      description: options.description || this.DEFAULT_DESCRIPTION,
      packFormat: options.packFormat || this.DEFAULT_PACK_FORMAT,
      supportedFormats: options.supportedFormats
    }

    try {
      // Parse all files to get structured data
      const parseResults = files.map(file => LanguageParser.parseFile(file))
      
      // Check for parsing errors
      const failedParses = parseResults.filter(r => !r.success)
      if (failedParses.length > 0) {
        failedParses.forEach(failed => {
          result.errors.push(...failed.errors)
        })
        if (result.errors.length > 0) {
          return result
        }
      }

      // Create ZIP archive
      const zip = new JSZip()

      // Generate pack.mcmeta
      const packMeta = this.generatePackMeta(config)
      zip.file('pack.mcmeta', JSON.stringify(packMeta, null, 2))
      result.generatedFiles.push({
        path: 'pack.mcmeta',
        type: 'meta'
      })

      // Add pack icon if provided
      if (config.packIcon) {
        try {
          const iconResult = await this.processPackIcon(config.packIcon)
          if (iconResult.success && iconResult.imageData) {
            zip.file('pack.png', iconResult.imageData)
            result.generatedFiles.push({
              path: 'pack.png',
              type: 'icon'
            })
          } else if (iconResult.warning) {
            result.warnings.push(iconResult.warning)
          }
        } catch (error) {
          result.warnings.push(`アイコンの処理に失敗しました: ${error instanceof Error ? error.message : 'Unknown error'}`)
        }
      }

      // Group files by namespace and locale
      const fileGroups = this.groupFilesByNamespaceAndLocale(files, parseResults)

      // Check if we have translations that should replace the original files
      const hasTranslations = config.includeTranslations && config.includeTranslations.length > 0
      const translationLocales = hasTranslations 
        ? new Set(config.includeTranslations!.map(t => t.locale))
        : new Set<string>()

      // Generate language files for each group
      for (const [groupKey, group] of fileGroups.entries()) {
        const { namespace, locale, files: groupFiles, parseResults: groupParseResults } = group
        
        // Skip original files if we have translations for the same locale
        // (translations will be handled separately and will override originals)
        if (hasTranslations && translationLocales.has(locale)) {
          result.warnings.push(`Skipping original ${namespace}/${locale} as translations are provided`)
          continue
        }
        
        // Merge entries from all files in this group
        const mergedEntries = this.mergeLanguageEntries(groupParseResults)
        
        if (mergedEntries.length === 0) {
          result.warnings.push(`No entries found for ${namespace}/${locale}`)
          continue
        }

        // Determine file format based on pack format
        const isLegacyFormat = config.packFormat <= 3
        const fileExtension = isLegacyFormat ? 'lang' : 'json'
        const filePath = `assets/${namespace}/lang/${locale}.${fileExtension}`
        
        let fileContent: string
        if (isLegacyFormat) {
          // Convert entries to .lang format (key=value)
          fileContent = mergedEntries
            .map(entry => `${entry.key}=${entry.value}`)
            .join('\n')
        } else {
          // Convert entries to JSON format
          const languageJson: { [key: string]: string } = {}
          mergedEntries.forEach(entry => {
            languageJson[entry.key] = entry.value
          })
          fileContent = JSON.stringify(languageJson, null, 2)
        }
        
        zip.file(filePath, fileContent)
        
        result.generatedFiles.push({
          path: filePath,
          type: 'language',
          namespace,
          locale
        })
      }

      // Add translated language files if provided
      if (config.includeTranslations && config.includeTranslations.length > 0) {
        const translationGroups = new Map<string, { [key: string]: string }>()
        
        // Group translations by namespace and locale
        config.includeTranslations.forEach(trans => {
          // Try to extract namespace from key (format: category.namespace.item)
          const parts = trans.key.split('.')
          const namespace = parts.length >= 3 ? parts[1] : 'minecraft'
          const locale = trans.locale  // Use the translation's target locale
          
          const groupKey = `${namespace}:${locale}`
          if (!translationGroups.has(groupKey)) {
            translationGroups.set(groupKey, {})
          }
          
          translationGroups.get(groupKey)![trans.key] = trans.value
        })

        // Generate files for translation groups
        for (const [groupKey, translations] of translationGroups.entries()) {
          const [namespace, locale] = groupKey.split(':')
          const isLegacyFormat = config.packFormat <= 3
          const fileExtension = isLegacyFormat ? 'lang' : 'json'
          const filePath = `assets/${namespace}/lang/${locale}.${fileExtension}`
          
          // Check if this file already exists from original files
          const existingFile = result.generatedFiles.find(f => f.path === filePath)
          let translationContent: string
          if (isLegacyFormat) {
            // Generate .lang format content
            translationContent = Object.entries(translations)
              .map(([key, value]) => `${key}=${value}`)
              .join('\n')
          } else {
            // Generate JSON format content
            translationContent = JSON.stringify(translations, null, 2)
          }
          
          if (existingFile) {
            // Merge with existing file
            const existingContent = zip.file(filePath)?.async('string')
            if (existingContent) {
              try {
                if (isLegacyFormat) {
                  // Merge .lang format files
                  const existingLangContent = await existingContent
                  const existingEntries = new Map<string, string>()
                  
                  // Parse existing .lang file
                  existingLangContent.split('\n').forEach(line => {
                    const [key, ...valueParts] = line.split('=')
                    if (key && valueParts.length > 0) {
                      existingEntries.set(key, valueParts.join('='))
                    }
                  })
                  
                  // Merge with new translations
                  Object.entries(translations).forEach(([key, value]) => {
                    existingEntries.set(key, value)
                  })
                  
                  // Generate merged content
                  translationContent = Array.from(existingEntries.entries())
                    .map(([key, value]) => `${key}=${value}`)
                    .join('\n')
                } else {
                  // Merge JSON format files
                  const existingJson = JSON.parse(await existingContent)
                  const mergedJson = { ...existingJson, ...translations }
                  translationContent = JSON.stringify(mergedJson, null, 2)
                }
                
                zip.file(filePath, translationContent)
                result.warnings.push(`Merged translations into existing file: ${filePath}`)
              } catch (error) {
                // Create new file if merging fails
                zip.file(filePath, translationContent)
              }
            }
          } else {
            // Create new file
            zip.file(filePath, translationContent)
            result.generatedFiles.push({
              path: filePath,
              type: 'language',
              namespace,
              locale
            })
          }
        }
      }

      // Generate the ZIP blob
      result.zipBlob = await zip.generateAsync({ type: 'blob' })
      result.success = true

      // Generate summary warnings if needed
      if (fileGroups.size === 0) {
        result.warnings.push('No valid language files could be processed')
      }

    } catch (error) {
      result.errors.push(`Resource pack generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }

    return result
  }

  private static generatePackMeta(options: ResourcePackOptions) {
    const versionInfo = getVersionByPackFormat(options.packFormat)
    const description = versionInfo 
      ? `${options.description} (${versionInfo.displayName})`
      : options.description

    const packMeta: any = {
      pack: {
        pack_format: options.packFormat,
        description: description
      }
    }

    if (options.supportedFormats) {
      packMeta.pack.supported_formats = options.supportedFormats
    }

    return packMeta
  }

  private static groupFilesByNamespaceAndLocale(
    files: LanguageFile[],
    parseResults: ParseResult[]
  ): Map<string, {
    namespace: string
    locale: string
    files: LanguageFile[]
    parseResults: ParseResult[]
  }> {
    const groups = new Map()

    for (let i = 0; i < files.length; i++) {
      const file = files[i]
      const parseResult = parseResults[i]

      if (!parseResult.success) continue

      const namespace = parseResult.detectedNamespace || 'minecraft'
      const locale = parseResult.detectedLocale || this.detectLocaleFromFileName(file.name) || 'en_us'
      
      const groupKey = `${namespace}:${locale}`
      
      if (!groups.has(groupKey)) {
        groups.set(groupKey, {
          namespace,
          locale,
          files: [],
          parseResults: []
        })
      }

      groups.get(groupKey).files.push(file)
      groups.get(groupKey).parseResults.push(parseResult)
    }

    return groups
  }

  private static mergeLanguageEntries(parseResults: ParseResult[]) {
    const entryMap = new Map()
    const duplicates = new Set<string>()

    for (const result of parseResults) {
      for (const entry of result.entries) {
        if (entryMap.has(entry.key)) {
          duplicates.add(entry.key)
          // Keep the later entry (could be made configurable)
        }
        entryMap.set(entry.key, entry.value)
      }
    }

    return Array.from(entryMap.entries()).map(([key, value]) => ({
      key,
      value,
      isDuplicate: duplicates.has(key)
    }))
  }

  private static detectLocaleFromFileName(filename: string): string | null {
    // Try to extract locale from filename patterns like:
    // - en_us.json
    // - ja_jp.lang
    // - mod_en_us.json
    // - some_mod_ja_jp.lang
    
    const nameWithoutExt = filename.replace(/\.(json|lang)$/i, '')
    
    // Look for locale pattern at the end
    const localeMatch = nameWithoutExt.match(/([a-z]{2}_[a-z]{2})$/i)
    if (localeMatch) {
      return localeMatch[1].toLowerCase()
    }

    return null
  }

  static async saveResourcePack(
    blob: Blob,
    filename: string = 'resource-pack.zip'
  ): Promise<boolean> {
    try {
      // Use browser download
      const url = URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = url
      link.download = filename
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      URL.revokeObjectURL(url)
      return true
    } catch (error) {
      console.error('Failed to save resource pack:', error)
      return false
    }
  }

  static validateResourcePackStructure(generatedFiles: ResourcePackResult['generatedFiles']): {
    isValid: boolean
    errors: string[]
    warnings: string[]
  } {
    const errors: string[] = []
    const warnings: string[] = []

    // Check for pack.mcmeta
    const hasPackMeta = generatedFiles.some(f => f.path === 'pack.mcmeta')
    if (!hasPackMeta) {
      errors.push('Missing pack.mcmeta file')
    }

    // Check for at least one language file
    const languageFiles = generatedFiles.filter(f => f.type === 'language')
    if (languageFiles.length === 0) {
      warnings.push('No language files generated')
    }

    // Validate file paths
    generatedFiles.forEach(file => {
      if (file.type === 'language') {
        if (!file.path.startsWith('assets/')) {
          errors.push(`Invalid language file path: ${file.path}`)
        }
        if (!file.path.endsWith('.json') && !file.path.endsWith('.lang')) {
          errors.push(`Language file should be JSON or LANG: ${file.path}`)
        }
      } else if (file.type === 'icon') {
        if (file.path !== 'pack.png') {
          errors.push(`Invalid pack icon path: ${file.path}`)
        }
      }
    })

    // Check for pack icon (informational)
    const hasPackIcon = generatedFiles.some(f => f.type === 'icon')
    if (hasPackIcon) {
      warnings.push('Pack icon added successfully')
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    }
  }

  /**
   * パックアイコン画像を処理する
   */
  private static async processPackIcon(iconFile: File | Blob): Promise<{
    success: boolean
    imageData?: ArrayBuffer
    warning?: string
  }> {
    try {
      // ファイル形式をチェック
      const fileType = iconFile.type || this.getFileTypeFromBlob(iconFile)
      if (!fileType.startsWith('image/')) {
        return {
          success: false,
          warning: 'アイコンファイルは画像形式である必要があります'
        }
      }

      // サイズをチェック（Minecraftでは推奨サイズは128x128だが、様々なサイズに対応）
      const maxSize = 5 * 1024 * 1024 // 5MB制限
      if (iconFile.size > maxSize) {
        return {
          success: false,
          warning: 'アイコンファイルは5MB以下である必要があります'
        }
      }

      // 画像をCanvasで処理して最適化
      const optimizedImage = await this.optimizePackIcon(iconFile)
      
      if (optimizedImage) {
        return {
          success: true,
          imageData: optimizedImage
        }
      } else {
        // 最適化に失敗した場合、元の画像をそのまま使用
        const arrayBuffer = await iconFile.arrayBuffer()
        return {
          success: true,
          imageData: arrayBuffer,
          warning: '画像の最適化に失敗しましたが、元の画像を使用します'
        }
      }
    } catch (error) {
      return {
        success: false,
        warning: `画像の処理中にエラーが発生しました: ${error instanceof Error ? error.message : 'Unknown error'}`
      }
    }
  }

  /**
   * Blobからファイルタイプを推測
   */
  private static getFileTypeFromBlob(blob: Blob): string {
    if (blob instanceof File) {
      return blob.type
    }
    // Blobの場合、拡張子から推測（簡易的）
    return 'image/png' // デフォルト
  }

  /**
   * パックアイコンを最適化（推奨サイズ128x128にリサイズ）
   */
  private static async optimizePackIcon(imageFile: File | Blob): Promise<ArrayBuffer | null> {
    try {
      return new Promise((resolve) => {
        const img = new Image()
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')

        if (!ctx) {
          resolve(null)
          return
        }

        img.onload = () => {
          // Minecraftの推奨サイズ128x128にリサイズ
          const targetSize = 128
          canvas.width = targetSize
          canvas.height = targetSize

          // アスペクト比を維持してリサイズ
          const scale = Math.min(targetSize / img.width, targetSize / img.height)
          const scaledWidth = img.width * scale
          const scaledHeight = img.height * scale
          const offsetX = (targetSize - scaledWidth) / 2
          const offsetY = (targetSize - scaledHeight) / 2

          // 背景を透明にクリア
          ctx.clearRect(0, 0, targetSize, targetSize)
          
          // 画像を描画
          ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight)

          // PNGとして出力
          canvas.toBlob((blob) => {
            if (blob) {
              blob.arrayBuffer().then(resolve).catch(() => resolve(null))
            } else {
              resolve(null)
            }
          }, 'image/png', 0.9)
        }

        img.onerror = () => resolve(null)

        // 画像を読み込み
        const url = URL.createObjectURL(imageFile)
        img.src = url
      })
    } catch (error) {
      console.error('Image optimization failed:', error)
      return null
    }
  }
}