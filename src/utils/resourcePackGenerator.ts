import JSZip from 'jszip'
import { LanguageFile } from '../App'
import { ParseResult, LanguageParser } from './languageParser'
import { getRecommendedVersion, getVersionByPackFormat } from './minecraftVersions'

export interface ResourcePackOptions {
  packName: string
  description: string
  packFormat: number
  supportedFormats?: number | number[] | { min_inclusive: number; max_inclusive: number }
  includeTranslations?: { key: string; value: string; locale: string }[]
}

export interface ResourcePackResult {
  success: boolean
  zipBlob?: Blob
  errors: string[]
  warnings: string[]
  generatedFiles: {
    path: string
    type: 'meta' | 'language'
    namespace?: string
    locale?: string
  }[]
}

export class ResourcePackGenerator {
  private static readonly DEFAULT_PACK_FORMAT = getRecommendedVersion().packFormat
  private static readonly DEFAULT_DESCRIPTION = 'Generated by LangPack Studio'

  static async generateResourcePack(
    files: LanguageFile[],
    options: Partial<ResourcePackOptions> = {}
  ): Promise<ResourcePackResult> {
    const result: ResourcePackResult = {
      success: false,
      errors: [],
      warnings: [],
      generatedFiles: []
    }

    if (files.length === 0) {
      result.errors.push('No files provided for resource pack generation')
      return result
    }

    const config: ResourcePackOptions = {
      packName: options.packName || 'Generated Language Pack',
      description: options.description || this.DEFAULT_DESCRIPTION,
      packFormat: options.packFormat || this.DEFAULT_PACK_FORMAT,
      supportedFormats: options.supportedFormats
    }

    try {
      // Parse all files to get structured data
      const parseResults = files.map(file => LanguageParser.parseFile(file))
      
      // Check for parsing errors
      const failedParses = parseResults.filter(r => !r.success)
      if (failedParses.length > 0) {
        failedParses.forEach(failed => {
          result.errors.push(...failed.errors)
        })
        if (result.errors.length > 0) {
          return result
        }
      }

      // Create ZIP archive
      const zip = new JSZip()

      // Generate pack.mcmeta
      const packMeta = this.generatePackMeta(config)
      zip.file('pack.mcmeta', JSON.stringify(packMeta, null, 2))
      result.generatedFiles.push({
        path: 'pack.mcmeta',
        type: 'meta'
      })

      // Group files by namespace and locale
      const fileGroups = this.groupFilesByNamespaceAndLocale(files, parseResults)

      // Generate language files for each group
      for (const [groupKey, group] of fileGroups.entries()) {
        const { namespace, locale, files: groupFiles, parseResults: groupParseResults } = group
        
        // Merge entries from all files in this group
        const mergedEntries = this.mergeLanguageEntries(groupParseResults)
        
        if (mergedEntries.length === 0) {
          result.warnings.push(`No entries found for ${namespace}/${locale}`)
          continue
        }

        // Convert entries to JSON format
        const languageJson: { [key: string]: string } = {}
        mergedEntries.forEach(entry => {
          languageJson[entry.key] = entry.value
        })

        // Create the file path: assets/{namespace}/lang/{locale}.json
        const filePath = `assets/${namespace}/lang/${locale}.json`
        zip.file(filePath, JSON.stringify(languageJson, null, 2))
        
        result.generatedFiles.push({
          path: filePath,
          type: 'language',
          namespace,
          locale
        })
      }

      // Add translated language files if provided
      if (config.includeTranslations && config.includeTranslations.length > 0) {
        const translationGroups = new Map<string, { [key: string]: string }>()
        
        // Group translations by namespace and locale
        config.includeTranslations.forEach(trans => {
          // Try to extract namespace from key (format: category.namespace.item)
          const parts = trans.key.split('.')
          const namespace = parts.length >= 3 ? parts[1] : 'minecraft'
          const locale = trans.locale
          
          const groupKey = `${namespace}:${locale}`
          if (!translationGroups.has(groupKey)) {
            translationGroups.set(groupKey, {})
          }
          
          translationGroups.get(groupKey)![trans.key] = trans.value
        })

        // Generate files for translation groups
        for (const [groupKey, translations] of translationGroups.entries()) {
          const [namespace, locale] = groupKey.split(':')
          const filePath = `assets/${namespace}/lang/${locale}.json`
          
          // Check if this file already exists from original files
          const existingFile = result.generatedFiles.find(f => f.path === filePath)
          if (existingFile) {
            // Merge with existing file
            const existingContent = zip.file(filePath)?.async('string')
            if (existingContent) {
              try {
                const existingJson = JSON.parse(await existingContent)
                const mergedJson = { ...existingJson, ...translations }
                zip.file(filePath, JSON.stringify(mergedJson, null, 2))
                result.warnings.push(`Merged translations into existing file: ${filePath}`)
              } catch (error) {
                // Create new file if merging fails
                zip.file(filePath, JSON.stringify(translations, null, 2))
              }
            }
          } else {
            // Create new file
            zip.file(filePath, JSON.stringify(translations, null, 2))
            result.generatedFiles.push({
              path: filePath,
              type: 'language',
              namespace,
              locale
            })
          }
        }
      }

      // Generate the ZIP blob
      result.zipBlob = await zip.generateAsync({ type: 'blob' })
      result.success = true

      // Generate summary warnings if needed
      if (fileGroups.size === 0) {
        result.warnings.push('No valid language files could be processed')
      }

    } catch (error) {
      result.errors.push(`Resource pack generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }

    return result
  }

  private static generatePackMeta(options: ResourcePackOptions) {
    const versionInfo = getVersionByPackFormat(options.packFormat)
    const description = versionInfo 
      ? `${options.description} (${versionInfo.displayName})`
      : options.description

    const packMeta: any = {
      pack: {
        pack_format: options.packFormat,
        description: description
      }
    }

    if (options.supportedFormats) {
      packMeta.pack.supported_formats = options.supportedFormats
    }

    return packMeta
  }

  private static groupFilesByNamespaceAndLocale(
    files: LanguageFile[],
    parseResults: ParseResult[]
  ): Map<string, {
    namespace: string
    locale: string
    files: LanguageFile[]
    parseResults: ParseResult[]
  }> {
    const groups = new Map()

    for (let i = 0; i < files.length; i++) {
      const file = files[i]
      const parseResult = parseResults[i]

      if (!parseResult.success) continue

      const namespace = parseResult.detectedNamespace || 'minecraft'
      const locale = parseResult.detectedLocale || this.detectLocaleFromFileName(file.name) || 'en_us'
      
      const groupKey = `${namespace}:${locale}`
      
      if (!groups.has(groupKey)) {
        groups.set(groupKey, {
          namespace,
          locale,
          files: [],
          parseResults: []
        })
      }

      groups.get(groupKey).files.push(file)
      groups.get(groupKey).parseResults.push(parseResult)
    }

    return groups
  }

  private static mergeLanguageEntries(parseResults: ParseResult[]) {
    const entryMap = new Map()
    const duplicates = new Set<string>()

    for (const result of parseResults) {
      for (const entry of result.entries) {
        if (entryMap.has(entry.key)) {
          duplicates.add(entry.key)
          // Keep the later entry (could be made configurable)
        }
        entryMap.set(entry.key, entry.value)
      }
    }

    return Array.from(entryMap.entries()).map(([key, value]) => ({
      key,
      value,
      isDuplicate: duplicates.has(key)
    }))
  }

  private static detectLocaleFromFileName(filename: string): string | null {
    // Try to extract locale from filename patterns like:
    // - en_us.json
    // - ja_jp.lang
    // - mod_en_us.json
    // - some_mod_ja_jp.lang
    
    const nameWithoutExt = filename.replace(/\.(json|lang)$/i, '')
    
    // Look for locale pattern at the end
    const localeMatch = nameWithoutExt.match(/([a-z]{2}_[a-z]{2})$/i)
    if (localeMatch) {
      return localeMatch[1].toLowerCase()
    }

    return null
  }

  static async saveResourcePack(
    blob: Blob,
    filename: string = 'resource-pack.zip'
  ): Promise<boolean> {
    try {
      if (window.electronAPI?.saveResourcePack) {
        // Use Electron's save dialog
        const buffer = await blob.arrayBuffer()
        const uint8Array = new Uint8Array(buffer)
        // .zipを除いたファイル名をElectronに渡す
        const baseFileName = filename.replace(/\.zip$/i, '')
        const savedPath = await window.electronAPI.saveResourcePack(Buffer.from(uint8Array), baseFileName)
        return savedPath !== null
      } else {
        // Fallback: use browser download
        const url = URL.createObjectURL(blob)
        const link = document.createElement('a')
        link.href = url
        link.download = filename
        document.body.appendChild(link)
        link.click()
        document.body.removeChild(link)
        URL.revokeObjectURL(url)
        return true
      }
    } catch (error) {
      console.error('Failed to save resource pack:', error)
      return false
    }
  }

  static validateResourcePackStructure(generatedFiles: ResourcePackResult['generatedFiles']): {
    isValid: boolean
    errors: string[]
    warnings: string[]
  } {
    const errors: string[] = []
    const warnings: string[] = []

    // Check for pack.mcmeta
    const hasPackMeta = generatedFiles.some(f => f.path === 'pack.mcmeta')
    if (!hasPackMeta) {
      errors.push('Missing pack.mcmeta file')
    }

    // Check for at least one language file
    const languageFiles = generatedFiles.filter(f => f.type === 'language')
    if (languageFiles.length === 0) {
      warnings.push('No language files generated')
    }

    // Validate file paths
    generatedFiles.forEach(file => {
      if (file.type === 'language') {
        if (!file.path.startsWith('assets/')) {
          errors.push(`Invalid language file path: ${file.path}`)
        }
        if (!file.path.endsWith('.json')) {
          errors.push(`Language file should be JSON: ${file.path}`)
        }
      }
    })

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    }
  }
}